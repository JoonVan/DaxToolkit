
// Depends on google-ctemplate system for substitutions.
__constant uint __daxNumberOfArrays = {{dax_array_count}};

void __daxGenerate(daxWork* work, uchar generator, daxArray* arrays)
{
  switch (generator)
    {
  case 0: // inputs, no generator.
    break;
{{#dax_generators}}
  case {{dax_id}}:
    // call the functor.
    {{dax_name}}(work, {{#dax_args}}&arrays[{{dax_array_index}}] {{#dax_args_separator}},{{/dax_args_separator}} {{/dax_args}});
    break;
{{/dax_generators}}
    }
}

__kernel void main(
  // we assume that there are __daxNumberOfArrays items in arrayCores.
  __global const __daxArrayCore* arrayCores,

  // for each global input-array
{{#dax_input_arrays}}
  __global const float* {{dax_name}} {{#dax_input_arrays_separator}},{{/dax_input_arrays_separator}}
{{/dax_input_arrays}}

 // DOH! I need to insert a ',' here conditionally. For now, I am going to
 // assumer there's always atleast 1 input and 1 output array.
 ,

  // for each global output-array
{{#dax_output_arrays}}
  __global float* {{dax_name}} {{#dax_output_arrays_separator}},{{/dax_output_arrays_separator}}
{{/dax_output_arrays}}
)
{
  daxWork work;
  __daxInitializeWorkFromGlobal(&work);

  daxArray arrays[{{dax_array_count}}];
  __daxInitializeArrays(arrays, arrayCores, __daxNumberOfArrays);

  // for each input array initialize the appropriate "daxArray" object.
{{#dax_input_arrays}}
  arrays[{{dax_index}}].InputDataF = {{dax_name}};
{{/dax_input_arrays}}

{{#dax_output_arrays}}
  arrays[{{dax_index}}].OutputDataF = {{dax_name}};
{{/dax_output_arrays}}
  //
  // Setup generators correctly for each of the arrays.
{{#dax_generated_arrays}}
  arrays[{{dax_index}}].Generator = {{dax_generator_id}};
{{/dax_generated_arrays}}

  // This will go over all the arrays and start generating every output array
  // for the work specified.
  for (uint cc=0; cc < __daxNumberOfArrays; cc++)
    {
    if (arrays[cc].OutputDataF != 0)
      {
      __daxGenerate(&work, arrays[cc].Generator, arrays[cc].Arrays);
      }
    }
}
