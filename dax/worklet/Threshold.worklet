//=============================================================================
//
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2012 Sandia Corporation.
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//
//=============================================================================

#ifndef __Threshold_worklet_
#define __Threshold_worklet_

#include <dax/exec/Cell.h>
#include <dax/exec/VectorOperations.h>
#include <dax/exec/WorkletMapCell.h>
#include <dax/exec/WorkletGenerateTopology.h>
#include <dax/math/Compare.h>

namespace dax {
namespace worklet {

template<typename T>

struct ThresholdFunction {
  const T Min;
  const T Max;
  int valid;

  DAX_EXEC_EXPORT ThresholdFunction(const T& min, const T&max):
    Min(min),Max(max),valid(1)
    {
    }

  DAX_EXEC_EXPORT void operator()(T value)
  {
    valid &= (dax::math::GreaterEqual()(value,Min)) &&
             (dax::math::LessEqual()(value,Max));
  }
};


template<typename ValueType>
class ThresholdClassify : public dax::exec::WorkletMapCell
{
public:
  typedef void ControlSignature(Topology, Field(Point), Field(Out));
  typedef _3 ExecutionSignature(_2);

  DAX_CONT_EXPORT
  ThresholdClassify(ValueType thresholdMin, ValueType thresholdMax)
    : ThresholdMin(thresholdMin), ThresholdMax(thresholdMax) {  }

  template<int  Size>
  DAX_EXEC_EXPORT
  dax::Id operator()(const dax::Tuple<ValueType,Size> &values) const
  {
    ThresholdFunction<ValueType> threshold(this->ThresholdMin,
                                           this->ThresholdMax);
    dax::exec::VectorForEach(values, threshold);
    return threshold.valid;
  }
private:
  ValueType ThresholdMin;
  ValueType ThresholdMax;
};

class ThresholdTopology : public dax::exec::WorkletGenerateTopology
{
public:
  // Returning a tuple of connections feels a bit clunky.  Is there a better
  // way of specifying the output cell type and generating a cell?
  typedef void ControlSignature(Topology, Topology(Out));
  typedef void ExecutionSignature(Topology::PointIds(_1),
                                  Topology::PointIds(_2));

  template<int NumInputPoints, int NumOutputPoints>
  DAX_EXEC_EXPORT
  void operator()(dax::Tuple<dax::Id,NumInputPoints> const& in,
                  dax::Tuple<dax::Id,NumOutputPoints> &out) const
  {
    out = in;
  }
};


}
} //dax::worklet

#endif
