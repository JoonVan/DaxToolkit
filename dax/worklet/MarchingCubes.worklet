//=============================================================================
//
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2012 Sandia Corporation.
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//
//=============================================================================

#ifndef __MarchingCubes_worklet_
#define __MarchingCubes_worklet_

#include <dax/CellTag.h>
#include <dax/exec/CellField.h>
#include <dax/exec/CellVertices.h>
#include <dax/exec/VectorOperations.h>
#include <dax/exec/WorkletMapCell.h>
#include <dax/exec/WorkletGenerateTopology.h>
#include <dax/Extent.h>

#include <dax/worklet/internal/MarchingCubesTable.h>

namespace
{
  DAX_EXEC_EXPORT
  dax::Vector3 interpolate(dax::Vector3 pointOne, dax::Vector3 pointTwo, dax::Scalar t)
    {
      //Cuda has lerp(a,b,t) which shoudl be used whenever possible for this
      return pointOne + t * (pointOne-pointTwo);
    }
}

namespace dax {
namespace worklet {

// --------------------------------------------------- GetVoxelClassification()
template<typename T>
DAX_EXEC_EXPORT
unsigned char GetVoxelClassification(const T isoValue,
                                     const dax::Tuple<T,8>& values )
{
  return ((values[0] <= isoValue) << 0 |
          (values[1] <= isoValue) << 1 |
          (values[2] <= isoValue) << 2 |
          (values[3] <= isoValue) << 3 |
          (values[4] <= isoValue) << 4 |
          (values[5] <= isoValue) << 5 |
          (values[6] <= isoValue) << 6 |
          (values[7] <= isoValue) << 7);
}

// -----------------------------------------------------------------------------
class MarchingCubesClassify : public dax::exec::WorkletMapCell
{
public:
  typedef void ControlSignature(Topology, Field(Point), Field(Out));
  typedef _3 ExecutionSignature(_2);

  DAX_CONT_EXPORT MarchingCubesClassify(dax::Scalar isoValue)
    : IsoValue(isoValue) {  }

  template<class InputCellTag>
  DAX_EXEC_EXPORT
  dax::Id operator()(
      const dax::exec::CellField<dax::Scalar,InputCellTag> &values) const
  {
    unsigned char voxelClass = GetVoxelClassification(IsoValue,
                                                      values.GetAsTuple());
    return dax::worklet::internal::marchingcubes::numFaces[voxelClass];
  }
private:
  dax::Scalar IsoValue;
};


// -----------------------------------------------------------------------------
class MarchingCubesTopology : public dax::exec::WorkletGenerateTopology
{
public:

  typedef void ControlSignature(Topology,
                                Topology(Out),
                                Field(Point,In),
                                Field(Point,In),
                                Field(Out));
  typedef void ExecutionSignature(_1,
                                  Vertices(_2),
                                  _3,
                                  _4,
                                  _5,
                                  VisitIndex,
                                  WorkId);

  DAX_CONT_EXPORT MarchingCubesTopology(dax::Scalar isoValue)
    : IsoValue(isoValue){ }


  template<class InputCellTag>
  DAX_EXEC_EXPORT void operator()(
      InputCellTag,
      dax::exec::CellVertices<dax::CellTagTriangle> &outVertices,
      const dax::exec::CellField<dax::Scalar,InputCellTag> &values,
      const dax::exec::CellField<dax::Vector3,InputCellTag> &coordinates,
      // The following argument needs to be fixed. It should be expressed
      // as a CellField class, but we do not yet have the ability to output
      // point data values from the generate topology worklet. Currently it
      // is a hack that defines a cell field as a tuple of coordinates for
      // each cell.
      dax::Tuple<dax::Vector3, 3> &outCoordinates,
      const dax::Id& inputCellVisitIndex,
      const dax::Id& workId) const
  {
    // These should probably be available through the voxel class
    const int voxelVertEdges[12][2] = { {0,1}, {1,2}, {3,2}, {0,3},
                            {4,5}, {5,6}, {7,6}, {4,7},
                            {0,4}, {1,5}, {3,7}, {2,6}};

    const unsigned char voxelClass =
        GetVoxelClassification(IsoValue, values.GetAsTuple());

    const dax::worklet::internal::marchingcubes::TriangleCases * const triCase =
        (dax::worklet::internal::marchingcubes::TriangleCases*)
        dax::worklet::internal::marchingcubes::triTable + voxelClass;

    const int * const TriCaseEdge = triCase->edges + inputCellVisitIndex * 3;

    //we need to save the coordinates and the connectivity
    for (int outVertIndex = 0;
         outVertIndex < outVertices.NUM_VERTICES;
         ++outVertIndex)
      {
      const int * const vert = voxelVertEdges[TriCaseEdge[outVertIndex]];

      // Find the weight for linear interpolation
      const dax::Scalar den = values[vert[1]]-values[vert[0]];
      const dax::Scalar num = IsoValue - values[vert[0]];
      const dax::Scalar t =  num/den ;

      // TODO: Move interpolate to a math function.
      //a + t * (a-b)
      outCoordinates[outVertIndex] = ::interpolate(coordinates[vert[0]],
                                                   coordinates[vert[1]],
                                                   t);
      outVertices[outVertIndex] =
          workId*outVertices.NUM_VERTICES + outVertIndex;
      }
  }

private:
  dax::Scalar IsoValue;
};

}
} //dax::worklet

#endif
