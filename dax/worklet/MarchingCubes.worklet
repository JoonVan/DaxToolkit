//=============================================================================
//
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2012 Sandia Corporation.
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//
//=============================================================================

#ifndef __MarchingCubes_worklet_
#define __MarchingCubes_worklet_

#include <dax/CellTag.h>
#include <dax/exec/CellField.h>
#include <dax/exec/CellVertices.h>
#include <dax/exec/VectorOperations.h>
#include <dax/exec/WorkletMapCell.h>
#include <dax/exec/WorkletGenerateTopology.h>
#include <dax/Extent.h>

#include <dax/worklet/internal/MarchingCubesTable.h>

namespace detail
{
  DAX_EXEC_EXPORT
  dax::Vector3 interpolate(dax::Vector3 pointOne, dax::Vector3 pointTwo, dax::Scalar t)
    {
      //Cuda has lerp(a,b,t) which shoudl be used whenever possible for this
      return pointOne + t * (pointTwo-pointOne);
    }
}

namespace dax {
namespace worklet {

// --------------------------------------------------- GetVoxelClassification()
template<typename T, typename U>
DAX_EXEC_EXPORT
int GetVoxelClassification(const T isoValue, const U& values )
{
  return ((values[0] > isoValue) << 0 |
          (values[1] > isoValue) << 1 |
          (values[2] > isoValue) << 2 |
          (values[3] > isoValue) << 3 |
          (values[4] > isoValue) << 4 |
          (values[5] > isoValue) << 5 |
          (values[6] > isoValue) << 6 |
          (values[7] > isoValue) << 7);
}

// -----------------------------------------------------------------------------
class MarchingCubesClassify : public dax::exec::WorkletMapCell
{
public:
  typedef void ControlSignature(Topology, Field(Point), Field(Out));
  typedef _3 ExecutionSignature(_2);

  DAX_CONT_EXPORT MarchingCubesClassify(dax::Scalar isoValue)
    : IsoValue(isoValue) {  }

  template<class InputCellTag>
  DAX_EXEC_EXPORT
  dax::Id operator()(
      const dax::exec::CellField<dax::Scalar,InputCellTag> &values) const
  {
    const int voxelClass = GetVoxelClassification(IsoValue,values);
    return dax::worklet::internal::marchingcubes::NumFaces[voxelClass];
  }
private:
  dax::Scalar IsoValue;
};


// -----------------------------------------------------------------------------
class MarchingCubesTopology : public dax::exec::WorkletGenerateTopology
{
public:

  typedef void ControlSignature(Topology,
                                Topology(Out),
                                Field(Point,In),
                                Field(Point,In),
                                Field(Out));
  typedef void ExecutionSignature(_1,
                                  Vertices(_2),
                                  _3,
                                  _4,
                                  _5,
                                  VisitIndex,
                                  WorkId);

  DAX_CONT_EXPORT MarchingCubesTopology(dax::Scalar isoValue)
    : IsoValue(isoValue){ }


  template<class InputCellTag>
  DAX_EXEC_EXPORT void operator()(
      InputCellTag,
      dax::exec::CellVertices<dax::CellTagTriangle> &outVertices,
      const dax::exec::CellField<dax::Scalar,InputCellTag> &values,
      const dax::exec::CellField<dax::Vector3,InputCellTag> &coordinates,
      // The following argument needs to be fixed. It should be expressed
      // as a CellField class, but we do not yet have the ability to output
      // point data values from the generate topology worklet. Currently it
      // is a hack that defines a cell field as a tuple of coordinates for
      // each cell.
      dax::Tuple<dax::Vector3, 3> &outCoordinates,
      const dax::Id& inputCellVisitIndex,
      const dax::Id& workId) const
  {
    using dax::worklet::internal::marchingcubes::TriTable;
    // These should probably be available through the voxel class
    const unsigned char voxelVertEdges[12][2] ={
        {0,1}, {1,2}, {3,2}, {0,3},
        {4,5}, {5,6}, {7,6}, {4,7},
        {0,4}, {1,5}, {2,6}, {3,7},
      };

    const int voxelClass =
        GetVoxelClassification(IsoValue, values.GetAsTuple());

    //we need to save the coordinates and the connectivity
    for (dax::Id outVertIndex = 0;
         outVertIndex < outVertices.NUM_VERTICES;
         ++outVertIndex)
      {
      const unsigned char edge = TriTable[voxelClass][(inputCellVisitIndex*3)+outVertIndex];
      const int vertA = voxelVertEdges[edge][0];
      const int vertB = voxelVertEdges[edge][1];

      // Find the weight for linear interpolation
      const dax::Scalar den = values[vertB]-values[vertA];
      const dax::Scalar num = IsoValue - values[vertA];
      const dax::Scalar t =  num/den ;

      outCoordinates[outVertIndex] = detail::interpolate(coordinates[vertA],
                                                         coordinates[vertB],
                                                         t);
      outVertices[outVertIndex] =
          workId*outVertices.NUM_VERTICES + outVertIndex;
      }
  }

private:
  dax::Scalar IsoValue;
};

}
} //dax::worklet

#endif
