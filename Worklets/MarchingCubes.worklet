//=============================================================================
//
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2012 Sandia Corporation.
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//
//=============================================================================

#ifndef __MarchingCubes_worklet_
#define __MarchingCubes_worklet_

#include <dax/exec/Cell.h>
#include <dax/exec/VectorOperations.h>
#include <dax/exec/WorkletDetermineNewCellCount.h>
#include <dax/exec/WorkletGenerateTopology.h>

namespace dax {
namespace worklet {

template<typename T>

struct MarchingCubesFunction {
  const T Min;
  const T Max;
  int valid;

  DAX_EXEC_EXPORT MarchingCubesFunction(const T& min, const T&max):
    Min(min),Max(max),valid(1)
    {
    }

  DAX_EXEC_EXPORT void operator()(T value)
  {
    valid &= (value >= Min) && (value <= Max);
  }
};


template<typename ValueType>
class MarchingCubesClassify : public dax::exec::WorkletDetermineNewCellCount
{
public:
  DAX_CONT_EXPORT
  MarchingCubesClassify(ValueType MarchingCubesMin, ValueType MarchingCubesMax)
    : MarchingCubesMin(MarchingCubesMin), MarchingCubesMax(MarchingCubesMax) {  }

  template<class InputCellType>
  DAX_EXEC_EXPORT
  void operator()(const InputCellType &daxNotUsed(cell),
                  const dax::Tuple<ValueType,InputCellType::NUM_POINTS> &values,
                  dax::Id &newCellCount) const
  {
    MarchingCubesFunction<ValueType> MarchingCubes(this->MarchingCubesMin,
                                           this->MarchingCubesMax);
    dax::exec::VectorForEach(values, MarchingCubes);
    newCellCount = MarchingCubes.valid;
  }

private:
  ValueType MarchingCubesMin;
  ValueType MarchingCubesMax;
};

//MarchingCubes only works when the topology is the same for input and output/
//The only special case so far is converting CellVoxel to CellHexahedron
class MarchingCubesTopology : public dax::exec::WorkletGenerateTopology
{
public:
  // Returning a tuple of connections feels a bit clunky.  Is there a better
  // way of specifying the output cell type and generating a cell?

  template<class InputCellType, int OutputCellSize>
  DAX_EXEC_EXPORT
  void operator()(const InputCellType &inputCell,
                  dax::Tuple<dax::Id,OutputCellSize> &outputConnections) const
  {
    //we can ignore the the requested cell Id to generate
    //on the work object since we know for MarchingCubes it is a pass through
    outputConnections = inputCell.GetPointIndices();
  }
};

}
} //dax::worklet

#endif
