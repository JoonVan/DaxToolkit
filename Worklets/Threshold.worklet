//=============================================================================
//
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//
//  Copyright 2012 Sandia Corporation.
//  Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
//  the U.S. Government retains certain rights in this software.
//
//=============================================================================

#ifndef __Threshold_worklet_
#define __Threshold_worklet_

#include <dax/exec/Cell.h>
#include <dax/exec/VectorOperations.h>
#include <dax/exec/WorkletDetermineNewCellCount.h>
#include <dax/exec/WorkletGenerateTopology.h>

namespace dax {
namespace worklet {

template<typename T>

struct ThresholdFunction {
  const T Min;
  const T Max;
  int valid;

  DAX_EXEC_EXPORT ThresholdFunction(const T& min, const T&max):
    Min(min),Max(max),valid(1)
    {
    }

  DAX_EXEC_EXPORT void operator()(T value)
  {
    valid &= (value >= Min) && (value <= Max);
  }
};


template<typename ValueType>
class ThresholdClassify : public dax::exec::WorkletDetermineNewCellCount
{
public:
  typedef void ControlSignature(Topology, Field(Point), Field(Out));
  typedef _3 ExecutionSignature(_1,_2);

  DAX_CONT_EXPORT
  ThresholdClassify(ValueType thresholdMin, ValueType thresholdMax)
    : ThresholdMin(thresholdMin), ThresholdMax(thresholdMax) {  }

  template<class InputCellType>
  DAX_EXEC_EXPORT
  dax::Id operator()(InputCellType,
      const dax::Tuple<ValueType,InputCellType::NUM_POINTS> &values) const
  {
    ThresholdFunction<ValueType> threshold(this->ThresholdMin,
                                           this->ThresholdMax);
    dax::exec::VectorForEach(values, threshold);
    return threshold.valid;
  }

private:
  ValueType ThresholdMin;
  ValueType ThresholdMax;
};

//Threshold only works when the topology is the same for input and output/
//The only special case so far is converting CellVoxel to CellHexahedron
class ThresholdTopology : public dax::exec::WorkletGenerateTopology
{
public:
  // Returning a tuple of connections feels a bit clunky.  Is there a better
  // way of specifying the output cell type and generating a cell?

  template<class InputCellType, int OutputCellSize>
  DAX_EXEC_EXPORT
  void operator()(const InputCellType &inputCell,
                  dax::Tuple<dax::Id,OutputCellSize> &outputConnections) const
  {
    //we can ignore the the requested cell Id to generate
    //on the work object since we know for threshold it is a pass through
    outputConnections = inputCell.GetPointIndices();
  }
};

}
} //dax::worklet

#endif
